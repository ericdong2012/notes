## day01

### 软件测试

#### 软件测试的定义

```
使用手工或工具手段对被测对象进行检测操作,其目的在于检验它是否满足规定的需求或是弄清预期结果和实际结果之间的差别; 一种实际输出与预期输出之间的审核或者比较过程
```



#### 软件测试的目的

```
 1）软件测试是为了发现错误而执行程序的过程。

​ 2）软件测试是为了证明程序有错，而不是证明程序无错。（发现错误不是唯一目的）

​ 3）软件测试是为了记录软件使用过程中的一些数据，从而为决策者提供依据。

​ 4）软件测试是为了降低开发风险。

是想以最少的人力，物力和时间找出软件中潜在的各种错误与缺陷，通过修正各种错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患以及带来的商业风险。
```

#### 软件测试的原则

```
 1）测试证明软件存在缺陷：我们的测试工作只能证明软件存在缺陷,不能证明软件没有缺陷.
​ 2）不能执行穷尽测试:具体测试操作的时候不可能将所有的情况都一一罗列出来,所以测试工作肯定有终止的时候.
​ 3）测试应当尽早介入:应该把“尽早测试和不断测试”作为测试人员的座右铭,不要等开发完成了以后再进行测试.
​ 4）缺陷存在群集现象:一般来讲针对用户最常用的20%功能(优先级别最高)的测试会得到完全执行, 而低优先级的测试(另外用户不常用的80%功能)就不是必要的,如果时间或经费不够,就暂时不做或者少做.
​ 5）某些测试需要专门的测试环境
​ 6）不存在缺陷谬论:不可能有没有缺陷的软件
​ 7）要妥善的保存一切文档,便于后期进行复用
```



### 开发过程及模型

开发过程

```
软件开发包括需求、设计、编码和测试等阶段，有时也包括维护阶段
```

开发模型

```
瀑布模型     虽有缺点，成熟， 还在使用
快速原型模型  适合小型功能的开发，和瀑布模型搭配使用
增量模型      
螺旋模型     风险分析
```



### 测试模型

```
V模型        编码完成后，测试介入
W(双V)模型   在需求分析结束后就可以进行需求分析测试
H模型        软件测试完全独立，贯穿整个生命周期，且与其他流程并发进行,成本高


```



### 测试分类(*)

```
 按照阶段进行划分
 	单元测试
 	集成测试   集成测试也称联合测试、组装测试，将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的				功能进行正确性检测的测试工作。主要目的是检查软件单位之间的接口是否正确
 	系统测试   测试内容：功能、界面、可靠性、易用性、性能、兼容性、安全性等,虽然系统测试包括冒烟测试和回归测				试，但三者之间是有严格的先后顺序的，即：先冒烟、再系统、后回归
 	
 按是否覆盖源码划分
 	黑盒测试  只关心软件的输入数据与输出数据。黑盒测试又分为功能测试和性能测试
 		功能测试   逻辑功能，界面，易用性，安装测试，兼用性测试
 		性能测试   稳定性测试，压力测试
 	白盒测试  基于代码的测试
 	灰盒测试  介于白盒测试与黑盒测试之间的一种测试
 	
按是否执行程序划分
	 静态测试    代码风格和规则审核
	 动态测试    检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等性能
	 
按是否自动化分
	手工测试
	自动化测试
	
其他
	冒烟测试：主干流程测试，确认软件的基本功能正常，可以进行后续的测试工作
	回归测试：	
	随机测试
	验收测试 
 	
```



### 测试流程(*)

```
(参加需求评审)学习业务---分析需求---工作评估---编写测试计划---准备测试环境，测试数据---执行测试，记录缺陷---跟踪bug,回归测试等---结束，编写测试汇总报告

编写测试计划
编写测试用例
测试，编写缺陷报告
编写测试汇总报告
```



### 测试用例设计原则

```
明确性
	测试人员要尽量避免测试用例存在含糊的因素,即通过、没通过或未进行测试
代表性
	尽量将具有相似功能的测试用例抽象合并,功能相似的用例要合并
简洁性
	测试用例简洁，可读性良好，测试过程目的明确，测试结果唯一,不要使用浮夸的修饰手法
```



### 测试用例(***)

#### 概念及特性

```
# 概念
测试用例又叫做test case，是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果,以便测试某个程序路径或核实是否满足某个特定需求

# 特性
2.1 有效性
测试用例的能够被使用，且被不同人员使用测试结果一致。

2.2 可复用性
良好的测试用例具有重复使用的功能.

回归测试

2.3 易组织性
好的测试用例会分门别类地提供给测试人员参考和使用。

2.4 可评估性
从测试评估的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准。

2.4 可管理性
从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准。
```

#### 测试用例八大要素

```
测试用例编号	测试用例标题	测试项目	预置条件	测试输入	预期输出	   操作步骤	        级别
ST-子项名-01 测试能否手机登录成功	手机登录	手机正常使用	手机号	正常登录 输入手机号并确认	重要


1). 测试用例编号
每个测试用例都有唯一的标识号，用以区别其他测试用例。

例：系统测试用例的编号这样定义规则： PROJECT1-ST-001 ，命名规则是项目名称＋测试阶段类型（系统测试阶段）＋编号。

2). 测试用例标题
对测试用例的简单描述。用概括的语言描述该测试用例的测试点。每个测试用例的标题不能够重复，因为每个测试用例的测试点事不一样的。

3). 测试项目

测试的项目属于哪个项目或者被测试的需求、被测的模块、被测的单元等等

4). 预置条件
执行当前测试用例需要的前提条件,如果前提条件不满足,则后面的测试步骤不能进行或者得不到预期结果

也就是测试环境包括硬件环境和软件环境

5). 测试输入
测试用例执行过程中需要加工的外部信息.根据测试用例的具体条件有手工输入、数据库等

6). 预期输出
测试用例的预期输出结果,包括返回值内容、界面响应结果等.

7). 操作步骤
执行当前测试用例需要经过的操作步骤，需要明确的给出一个步骤的描述，测试用例执行人员可以根据该步骤完成测试用例执行

8). 级别
对于测试用例的重要程度的区分.包含如下几种:

    高级别
    保证系统基本功能、核心业务、重要特性、实际使用频率比较高的用例

    中级别
    重要程度介于高和低之间的测试用例

    低级别
    实际使用的频率不高，对系统业务功能影响不大的模块或功能的测试用例

还有：
	用例的设计者: 能准确找到测试用例的设计人员,对用例修改时能方便找到人员
    用例设计日期: 方便检查用例的设计进度
    对应的开发人员: 出现bug后能及时找到相应的人员进行修复
    测试结果: 执行用例最后执行的结果, 包括:pass、fail、block
    测试类型: 功能、性能、压力等等
```

#### 案例：新浪邮箱

```
# https://mail.sina.com.cn/register/regmail.php

用例编号	用例标题	测试模块	预置条件	测试输入	测试步骤	预期结果	实际输出	级别
sina-st-001	注册测试用户名	注册	联网正常	abc1	"1.输入测试用户名"	注册成功	注册成功	重要
```



### 测试用例设计方法(***)

#### 等价类划分法：

概念：

```
从大量数据里划分范围（每个范围内的数据测试效果是等价的所以每个范围是一个等价类），然后从每个范围中挑选代表数据，这些代表数据能反应这个范围内数据的测试结果。
```

划分：

```
有效等价类
	有效等价类是指对对于程序的规格说明来说是合理的、有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能.
	
无效等价类
	无效等价类指对程序的规格说明是不合理的、无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。利用无效等价类可校验程序对于无效数据的处理能力,检测程序的健壮性、容错能力
```

案例： 1-100 两个整数的运算

```
用例编号	用例标题	测试模块	预置条件	测试输入	测试步骤	预期结果	实际输出	级别
jsq-st-001	有效等价类测试	计算器	整数计算器	x=1,y=9	输入x,y,点击+号计算	10	    10	       高
jsq-st-002	有效等价类测试	计算器	整数计算器	x=99,y=10	输入x,y,点击+号计算	109	109	高
jsq-st-003	无效效等价类测试	计算器	整数计算器	x=0,y=10	输入x,y,点击+号计算	提示输入错误	程序出现终止	高
jsq-st-004	无效效等价类测试	计算器	整数计算器	x=10,y=0	输入x,y,点击+号计算	提示输入错误	提示输入错误	高
jsq-st-005	无效效等价类测试	计算器	整数计算器	x=-1,y=1	输入x,y,点击+号计算	提示输入错误	提示输入错误	高
jsq-st-006	无效效等价类测试	计算器	整数计算器	x=10,y=-2	输入x,y,点击+号计算	提示输入错误	提示输入错误	高
jsq-st-007	无效效等价类测试	计算器	整数计算器	x=10,y=101	输入x,y,点击+号计算	提示输入错误	提示输入错误	高
jsq-st-008	无效效等价类测试	计算器	整数计算器	x=10,y=&*	输入x,y,点击+号计算	提示输入错误	提示输入错误	高
```



案例二：测试QQ账号的合法符合规范

分析

| 明确需求         | 输入6-10位的自然数 |                                                     |
| ---------------- | ------------------ | --------------------------------------------------- |
| **有效等价类**   | 有效等价类         | 自然数个数大于6小于10个                             |
| **无效等价类**   | 无效等价类         | 小于6个、大于10个、中文、空格、英文、特殊字符、小数 |
| **设计测试用例** | 有效等价类测试用例 | 无效等价类测试用例                                  |

测试用例

| 用例编号     | 等价类划分   | 输入     | 预期结果 | 测试结果 | 重要级别 |
| ------------ | ------------ | -------- | -------- | -------- | -------- |
| UT-QQ账号-01 | 有效等价类   | 12345678 | 正确     | 正确     | 高级     |
| UT-QQ账号-02 | 无效等价爱类 | 12       | 错误     | error    | 高级     |





## day02

### 测试用例设计方法(***)

#### 边界值法

概念: 对输入或输出边界值进行测试的, 通常作为等价类划分法的补充

常见的边界值:

- **边界点(上点):**输入范围的边界点
- **离点:** 离边界点最近的点
- **内点:** 输入范围内的任意一个点



案例： 测试qq账号是否符合规范(qq号是6-10位的整数)

分析：

| 上点 | 6个, 10个          |
| ---- | ------------------ |
| 离点 | 5个, 9个, 7个,11个 |
| 内点 | 8个                |



测试用例：

| 用例编号             | 等价类划分 | 输入                         | 预期结果 | 实际结果 |
| -------------------- | ---------- | ---------------------------- | -------- | -------- |
| UT-QQ是否符合规范-01 | 有效等价类 | 6个                          | 正确     |          |
| UT-QQ是否符合规范-02 | 有效等价类 | 10个                         | 正确     |          |
| UT-QQ是否符合规范-03 | 无效等价类 | 5个                          | 错误     |          |
| UT-QQ是否符合规范-04 | 有效等价类 | 7个                          | 正确     |          |
| UT-QQ是否符合规范-05 | 无效等价类 | 11个                         | 错误     |          |
| UT-QQ是否符合规范-06 | 有效等价类 | 9个                          | 正确     |          |
| UT-QQ是否符合规范-07 | 有效等价类 | 8个                          | 正确     |          |
| UT-QQ是否符合规范-08 | 无效等价类 | 特殊符号,例如: #,¥ *、空格等 | 错误     |          |
| UT-QQ是否符合规范-09 | 无效等价类 | 数字+特殊符号                | 错误     |          |



#### 判定表法

概念：判定表也决策表,分析和表达多逻辑条件下执行不同操作的工具

适用场景：适合于有多个输入和对个输出,输入和输出之间有相互的组合关系, 输入输出之间有相互的制约和依赖关系

组成： 

​	1） 条件桩（Condition Stub）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。

​	2） 动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。

​	3） 条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。

​	4） 动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。



规则和化简：

​	规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则，在判定表中贯穿条件项和动作项的一列就是一条规则。显然判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列; 一条规则就是一条测试用例。

​	化简： 规则合并有两条或多条规则具有相同动作,并且其条件项之间存在着极为相似的关系。



步骤:

1. 明确规则个数
2. 列出所有条件桩和动作桩
3. 填入条件项
4. 填入动作项,等到初始判定表
5. 简化,合并相似规则



案例1：对于功率大于50马力的机器、维修记录不全或运行10年以上的机器,应优先维修.

1.1 . 明确规则个数

这里有三个条件:大于50马力、维修记录不全、运行10年以上, 每个条件有2种取值,所以有八种规则.



1.2. 列出条件桩和动作桩

| 条件桩 | 功率大于50马力? |
| ------ | --------------- |
|        | 维修记录不全?   |
|        | 运行超过10年?   |
| 动作桩 | 优先处理        |

1.3. 填入条件项

1.4. 填入动作项等到初始判定表

| 条件桩 | 条件项          | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ------ | --------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|        | 功率大于50马力? | Y    | Y    | Y    | Y    | N    | N    | N    | N    |
|        | 维修记录不全?   | Y    | Y    | N    | N    | Y    | Y    | N    | N    |
|        | 运行10年以上?   | Y    | N    | Y    | N    | Y    | N    | Y    | N    |
| 动作桩 | 优先处理?       | X    | X    | X    |      | X    |      | X    |      |
|        | 其他处理        |      |      |      | X    |      | X    |      | X    |

1.5 . 简化判定表

通过初始的判定表我们发现:

1. 在三个条件中有2个不满足时,剩下的一个完全没有参考价值,可以进行简化.

   只有功率大于50马力、维修记录全的、运行十年以上的才优先处理;

   其他处理的情况是:满足动力大于50马力、维修功能完全、没有运行10年以上中只要满足两项

2. 简化后为

| 条件桩 | 条件项          | 1    | 2    | 3    | 4    | 5    |
| ------ | --------------- | ---- | ---- | ---- | ---- | ---- |
|        | 功率大于50马力? | Y    | Y    | N    | N    | Y    |
|        | 维修记录不全?   | Y    | N    | -    | -    | N    |
|        | 运行10年以上?   | -    | Y    | Y    | N    | N    |
| 动作桩 | 优先处理?       | X    | X    | X    |      |      |
|        | 其他处理        |      |      |      | X    | X    |

注意: “-”表示取值与否不影响触发的动作.即,不影响规则



案例2：公交一卡通自动充值系统

系统要求:

- 系统只接收50或100元纸币，一次只能使用一张纸币，一次充值金额只能为50元或100元。
- 若输入50元纸币，并选择充值50元，完成充值后退卡，提示充值成功；
- 若输入50元纸币，并选择充值100元，提示错误，并退回50元；
- 若输入100元纸币，并选择充值50元，完成充值后退卡，提示充值成功，找零50元；
- 若输入100元纸币，并选择充值100元，完成充值后退卡，提示充值成功；
- 若输入纸币后在规定时间内不选择充值按钮，找零，并提示错误；
- 若选择充值按钮后不输入货币,提示错误

​	

2.1 明确规则个数

| 规则个数(条件桩) | 输入50元  |
| ---------------- | --------- |
|                  | 输入100元 |
|                  | 充值50元  |
|                  | 充值100元 |

2.2. 列出条件桩和动作桩

| 动作桩 | 提示充值成功   |
| ------ | -------------- |
|        | 充值成功并退卡 |
|        | 退卡           |
|        | 找零           |

2.3. 列入条件项

2.4. 填入动作项,等待初始的判定表

| 输入条件 |                | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| -------- | -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|          | 输入50元       | Y    | Y    |      |      | X    |      |      |      |
|          | 输入100元      |      |      | Y    | Y    |      | X    |      |      |
|          | 充值50元       | Y    |      | Y    |      |      |      | X    |      |
|          | 充值100元      |      | Y    |      | Y    |      |      |      | X    |
|          |                |      |      |      |      |      |      |      |      |
| 动作桩   | 充值成功并退卡 | X    |      | X    | X    |      |      |      |      |
|          | 提示充值成功   | X    |      | X    | X    |      |      |      |      |
|          | 找零           |      | X    | X    |      | X    | X    |      |      |
|          | 提示错误       |      | X    |      |      | X    | X    | X    | X    |

2.5 简化

这个案例中每个条件都是独立的,没有可以简化的



2.6.测试用例设计

![](images\公交系统测试用例.png)







#### 因果图法

因果图法是通向判定表法的一个中间过程，见excel中因果判断表



#### 正交法

概念： 正交法,也叫正交实验法或者正交排列法, 就是使用最小的测试过程集合获得最大的测试覆盖率

构成：

​	正交表时一种特制的表, 一般记为$$Ln(m^k)$$

- n是表的行数,也就是需要测试组合的次数

- k是表的列数, 表示控件个数(因素的个数,或因子的个数)

- m是每个控件包含的取值个数(各因素的水平数,即各因素的状态数)

  

  例如:$$L9(3^4)$$ 正交表如下

![](images\正交构成.png)



案例：

![](images\allpairs1.png)



2.1 步骤

1. 根据需求把空间即其取值列举出来
2. 根据空间和空间的取值个数,选择一个合适的正交表
   - 根据控件的个数,选择正交表的次幂,也就是正交表中包含的最大值, 例如,4个控件,选择4次幂
   - 根据控件取值个数,选择正交表的底,也就是正交表包含的最大值, 例如, 每个控件有3个取值,底是3
3. 把控件及其取值映射到正交表中
   - 把控件名字分别映射到正交表的列名位置
   - 把正交表中每一列的数字分别用对应的控件取值替代
4. 根据正交表,编写测试用例

2.2 “字符属性设置”的测试用例编写

**(1). 列举因子表**

| 字体     | 字符样式 | 字体颜色 | 字号 |
| -------- | -------- | -------- | ---- |
| 仿宋     | 粗体     | 红色     | 20号 |
| 楷体     | 斜体     | 绿色     | 30号 |
| 华文彩云 | 下划线   | 蓝色     | 40号 |

**(2) 确定使用的正交表**

| 确定采用的正交表 |
| ---------------- |
| $$L9(3^4)$$      |

**(3). 把控件及其取值映射到正交表中**

> 通过allpairs 工具， 在allpairs下新建 test.txt 将需要的数据导入，命令行执行
>
>  allpairs.exe test.txt  >  result.txt 

![正交表3](images/allpairs3.png)

**(4). 编写测试用例**

上图正交表每一行都是一条测试用例,, 此处仅列出2条

| 用例编号             | 输入                                          | 预期结果                 | 实际结果 | 是否是bug |
| -------------------- | --------------------------------------------- | ------------------------ | -------- | --------- |
| UT-设置字符子项测-01 | 字体:仿宋; 字符样式: 粗体; 颜色:红色; 字号:20 | 仿宋、 粗体、 红色、20号 |          |           |
| UT-设置字符子项测-02 | 字体:仿宋; 字符样式: 粗体; 颜色:红色; 字号:30 | 仿宋、 粗体、 红色、20号 |          |           |



使用场景

- 需求中条件的组合量比较大的时候
- 需求两个两个相互组合的时候



#### 场景法

适用场景： 多个功能组合测试的场景适合使用场景法

 步骤

1. 分析需求,确定基本流程、备选流程、异常流程
2. 绘制流程图,确定流程路径, 根据流程图生成不同的场景
3. 每一个场景就是一条测试用例

案例

2.1 需求描述

用户网上购买商品, 整个订购过程为：用户登录到网站后，进行书籍的选择，当选好自己心仪的书籍后进行订购，这时把所需图书放进购物车，等进行结帐的时候，用户需要登录自己注册的帐号，登录成功后，进行结帐并生成订单，整个购物过程结束。

2.2 测试用例实现

**(1). 分蓄需求,确定业务流程(基本流程、备选流程、异常流程)**

| 基本流程  | 用户登录到网站，书籍的选择，进行订购，把所需图书放进购物车，等进行结帐的时候，登录自己的帐号，登录成功后，生成订单. |
| --------- | ------------------------------------------------------------ |
| 备选流程1 | 账号不存在                                                   |
| 备选流程2 | 账号错误                                                     |
| 备选流程3 | 密码错误                                                     |
| 备选流程4 | 没有选购书籍                                                 |
| 备选流程5 | 退出系统                                                     |

**(2). 绘制流程图,确定流程路径, 根据流程图生成不同的场景**

| 场景1-购物成功     | 基本流程 |           |
| ------------------ | -------- | --------- |
| 场景2-账号不存在   | 基本流程 | 备选流程1 |
| 场景3-账号错误     | 基本流程 | 备选流程2 |
| 场景4-密码错误     | 基本流程 | 备选流程3 |
| 场景5-没有选购书籍 | 基本流程 | 备选流程4 |

**(3). 编写测试用例, 对于每一个场景都需要确定测试用例。**

| 测试用例编号      | 输入条件 | 账号 | 密码        | 是否选购书籍 | 预期结果                       |
| ----------------- | -------- | ---- | ----------- | ------------ | ------------------------------ |
| ST-系统测试子项-1 | 场景1    | 张三 | admin@123   | Y            | 购物成功                       |
| ST-系统测试子项-2 | 场景2    | 李四 | N           | N            | 提示账号不存在                 |
| ST-系统测试子项-3 | 场景3    | 赵六 | admin       | N            | 提示账号错误, 返回基本流程     |
| ST-系统测试子项-4 | 场景4    | 张三 | Admin123&…… | N            | 提示密码错误,返回基本流程      |
| ST-系统测试子项-5 | 场景5    | 张三 | admin@123   | N            | 提示没有选购书籍, 返回基本流程 |





#### 其他

功能图法

错误缺陷法(经验推断法)



### 缺陷(***)

#### 定义

```
存在于软件(程序、数据、文档中的)那些不符合用户需求的问题.
```

#### 表现形式

```
功能,特性没有实现或者部分实现
设计不合理,功能特性不明确,逻辑不清楚或存在矛盾
产品实际结果和所期望的几个不一致
没有达到需求规格说明书所规定的性能指标
运行出错,包括运行中断,系统崩溃,界面混乱等
数据不正确,或者精度不够,不完整或者格式不统一
用户不能接受的其他问题,比如等待时间过长,界面不美观
硬件或者系统软件上存在的其他问题
```

#### 产生原因

```
需求解释或者记录错误
用户需求定义错误
设计说明存在错误
编码说明,程序代码存在错误
硬件或软件上存在错误
其他,如文档错误,内容不正确,拼写错误等
```



缺陷状态，严重程度，优先级，分类

```
# 状态
New:缺陷的初始状态；
Open：开发人员开始修改缺陷；
Fixed：开发人员修改缺陷完毕；
Closed：回归测试通过,关闭缺陷；
Reopen：回归测试失败,再次打开；
Postpone：推迟修改；
Rejected：开发人员认为不是程序问题，不用修改；
Duplicate：与已提交的Defect重复；
Abandon：被Reject和Duplicate的Defect，测试人员确认后的确不是问题，将Defect置为此状态。

# 严重程度
一般来说，软件的严重程度分为五个等级：

(1) Fatal 致命的缺陷
造成系统或应用程序崩溃、死机、系统挂起，或造成数据丢失，主要功能完全丧失，导致本模块以及相关模块异常等问题

(2) Critical 严重错误的软件缺陷
系统的主要功能部分丧失、数据不能保存，系统的次要功能完全丧失。问题局限在本模块，导致模块功能失效或异常退出。如致命的错误声明，程序接口错误，数据库的表、业务规则、缺省值未加完整性等约束条件。

(3) Major 一般的软件缺陷
次要功能没有完全实现但不影响使用。如：提示信息不太准确，或用户界面差，操作时间长，模块功能部分失效等，

(4)Minor 较小的软件缺陷
较小错误的软件缺陷，使操作者不方便或遇到麻烦，但它不影响功能性的操作和执行，如错别字、界面不规范等

(5) Enhancemental 建议问题
由问题提出人对测试对象的改进意见或测试人员提出的建议、质疑。



# 优先级
由于缺陷的等级不一样,导致处理缺陷的先后顺序不一样,一般分为下面几种:

(1) P1 立即解决
缺陷导致系统几乎不能完全运行、使用，或严重妨碍测试的执行，需立即修正、尽快修正；

(2) P2 高级优先
缺陷严重，影响测试，需要优先考虑修正，如不超过24小时修正；

(3)P3 正常级别
缺陷需要修改,只要正常排队修复就可以

(4)P4 低优先级
缺陷可以在开发人员有时间的时间修复,若没时间可以不修正


# 分类
系统缺陷    程序引起的异常退出，死循环，
数据缺陷    数据约束错误
数据库缺陷  数据库死锁，连接错误
接口缺陷    数据通信错误
功能缺陷    功能无法实现
```



#### 缺陷报告的书写(***)

![](images\缺陷报告1.png)



![](images\缺陷报告.png)



#### 缺陷报告的注意事项

```
尽量确保缺陷可以重现，如果提交的缺陷无法重现,会影响开发人员的工作效率,甚至会影响到测试人员

简洁,准确,完整（测试人员提交缺陷报告的时候,要站在开发人员的角度上问题,要确保开发人员能迅速定位问题,而不会产生理解上的歧义）

一个缺陷一个报告:有的测试人员喜欢在一个缺陷报告中提交多个缺陷,这是不专业的
    不便于分配:缺陷报告中有两个缺陷,分别属于不同的开发人员
    不便于验证:缺陷报告中有两个缺陷,一个已经解决一个没有解决,缺陷报告应不应该关闭
```



#### 缺陷报告的书写规范

```
标题:应该保持简短,准确,提供缺陷的本质信息，尽量按缺陷发生的原因与结果的方式书写

复现步骤:应包含如何使别人能够很容易的复现该缺陷的完整步骤，不要包含过多的多余的步骤,句子简洁，不要丢失		必要的操作步骤

避免常见的错误

    避免使用 我 你 等人称代词,可以直接使用动词,或者必要的时候使用"用户","开发","测试"指代人物
    避免使用情绪化的语言或者强调符号
    避免使用"可能","看上去应该","大概"等含义模糊的词汇
    避免使用自认为很幽默的语句,不要玩梗,只需要客观的描述即可
    避免提交不缺的的缺陷,提交的缺陷必须能复现
```

#### 缺陷密度

```
定义：每千行代码的缺陷数来测量，单位： 个/kloc
例如：一个29.6万行的程序总共有145个缺陷，则缺陷密度 1000*145/296000 = 0.49 个/kloc
```









## day03

### 禅道

使用见课件 或者 教学资料中的  缺陷管理工具---禅道篇

```
# 禅道登录账号:admin, 密码:123456  (进入需要更改密码)

# 角色添加
点击组织---添加用户(批量添加)  


产品经理需求设计
# 产品创建
产品经理登录---点击产品---(右上角)添加产品


# 产品计划
点击产品---点击计划---创建计划

# 产品模块
点击产品---点击模块---输入相应信息

# 产品需求
点击产品---点击需求---提需求

# 产品需求评审
产品主管登录---点击产品---点击需求---点击评审
如果评审不通过，相关人员登录够，点击需求，可重新进行编辑，再提交


# 产品需求变更
产品主管登录---点击产品---点击需求---点击变更




项目经理立项
# 立项
项目经理登录---点击项目---添加相应信息

# 设置团队
点击项目---点击团队---团队管理

# 关联需求
点击项目---点击需求---关联需求---勾选需求---点击保存

# 添加任务
点击项目---点击任务---建任务---添加相应信息(任务类型为事务，可指派给多个人，用于总结报告)
或者
点击项目---点击需求---分解任务

？？？ 需求和任务的区别
有了需求才能派发任务，任务可以对需求进行分解




开发阶段
# 领取任务
开发登录---点击项目---点击任务---点击指派给我的---开始

# 创建版本
点击项目---点击版本---创建版本


# 版本关联需求
管理员登录---组织---给研发添加新的权限---版本/关联需求
开发登录---项目---版本---可以看到关联需求


？？？ 为什么要关联需求(多个任务的合集)


# 提交测试
方式1：
开发登录---点击项目---点击版本---提交测试

方式2：
测试---版本---提交测试





测试阶段
# 编写测试用例，关联用例
测试人员登录---测试---用例---建用例
测试人员登录---测试---版本---关联用例(未关联的才显示出来)

# 用例评审
管理员登录---后台---自定义---用例---评审流程---开启
测试人员登录---测试---用例---建用例

# 用例执行及bug提交
测试人员登录---测试---用例---执行---修改测试结果，如果失败，跳转到bug界面

bug界面对bug做详细说明


# 开发解决bug
开发登录---测试---bug---确认bug---解决bug

# 测试回测
测试登录---如果bug依然存在，点击激活，已解决，点击关闭

```

**补充：**

```
jira使用：  https://blog.csdn.net/lelemom/article/details/86708401
```







## day04

iwebshop手工测试

### 1. 测试流程

```
搭建测试环境(重点)

快速的熟悉项目

编写测试计划

编写测试方案

设计、编写、执行测试用例(重点)，回归测试

生成测试报告
```



### 2. 环境搭建

```
# xampp 安装
双击 xampp-win32-1.8.2-0-VC9-installer.exe ，将安装目录更改为 D 盘

# 将附件中的iwebshop.zip解压，把解压后的iwebshop文件夹复制到xampp安装路径下的 htdocs目录内，如D:\xampp\htdocs

# 修改xampp 端口，apache 端口(apache httpd.conf 80->8088, apache httpd-ssl.conf 443->4431)  , mysql 端口(my.ini有两处需要更改client, mysqld 3306-> 3307)

# 启动xampp, 并在浏览器中访问   http://127.0.0.1:80/iwebshop/  
勾选我同意，点击下一步
数据库地址：localhost:3307  (更改为自己的)
数据库名称：iwebshop
账户: root
密码：          (空)

点击检测   ok
管理员密码： admin,admin123456

完整安装

安装完成，显示 到前台，到后台


# 前台地址，后台地址
前台地址：
http://127.0.0.1:8088/iwebshop/index.php?controller=site&action=index.php

后台地址：
http://127.0.0.1:8088/iwebshop/index.php?controller=systemadmin&action=index
```



### 3. 快速熟悉项目

```
后台地址：
http://127.0.0.1:8088/iwebshop/index.php?controller=systemadmin&action=index

# 项目结构  详细信息见 教学资料 Iwebshop组织架构图.html
商品	
	商品管理
		商品列表
		商品添加
	商品分类
	品牌
	模型
	热门搜索
	
会员
订单
营销
统计
系统
工具

# 确定测试范围
上面列出的功能模块

需求编号  功能名称  测试类型   path   优先级
iwebshop-SRS-H-001	添加商品	功能测试	iwebshop后台\商品\商品管理\商品列表\	高

```



### 4. 测试计划及测试方案

```
# 测试计划 
见教学资料


# 测试方案
见教学资料
```



### 5. 测试用例编写

5.1UI测试

```
# 首页内容(结合数据库)
navicat 连接数据库iwebshop ,端口:3307, 账号：root,密码：  

首页分析及数据库对应：(详细对应下面的截图) 
	商品分类  iwebshop-category
	热门搜索  iwebshop-keyword
	shop资讯  iwebshop-artical
	热卖商品
	最新商品
	服饰鞋帽
	公告通知
	关键字
	化妆品
	家居加装
	电脑手机数码
	品牌列表
	最新评论
	帮助信息
```



![](images\首页数据库.png)



```
# 首页分类数据库语句确定，测试用例，缺陷bug书写 (详细见手工测试成果物)        
select * from iwebshop_category where parent_id=0 and visibility=1 order by sort limit 5

# 热门搜索数据库语句确定
select * from iwebshop_keyword where hot=1 order by `order` limit 5

```



5.2 独立功能点测试

```
# 会员添加  iwebshop_user  +  iwebshop_member + iwebshop_area （详见手工项目成果物/添加会员分析，添加会员数据构造，添加会员测试用例）

# 会员注册（详见手工项目成果物）

# 会员搜索 （详见手工项目成果物）

等价划分法
```



## day05

### 5.测试用例编写

5.3  独立功能点测试

```
# 鞋帽服饰(正交法)
品牌	价格
不限	不限
JackJones	1-99
七匹狼	100-199
lee	200-299
adidas阿迪达斯	
nike/耐克	
kappa/背靠背	

通过allpairs 生成 正交表 ，编写测试用例


# 鞋帽服饰 价格输入(等价划分法)


```



5.4 场景测试

> 使用于核心业务模块

![](images\场景法.png)



编写测试用例：一条业务场景就是一条测试用例

5.5  购物系统

深度图，广度图

```
# 广度图
任意选取一个功能点作为开始点；
画出该功能所有可达功能；
从左至右依次画出每个功能的可达功能；(注意：每个功能的可达功能画一次即可)
其他的功能和画过的功能直接结束即可。


# 深度图
任意选取一个功能点作为开始点；
画出该功能的所有可达功能；
逐层从最左侧开始依次向下画；（注意：每个功能的可达功能画一次即可）
其他的功能和画过的功能直接结束即可。
```

购物系统深度，广度图

```
见教学资料
```



5.6 非功能测试

```
包括 效率性、可靠性、可移植性、可用性
```



5.7 接口测试



```
获取接口地址(根据接口文档/根据抓包工具抓取)
分析接口请求数据(入参、处理、出参）
构造接口数据
编写测试用例
根据工具或者代码执行接口，比对结果即可
```

常见的接口： 内部接口， 三方接口

接口文档



5.8 测试报告

见教学资料中测试报告(重点： bug 汇总， 风险评估)



## day06

### 自动化测试

#### 1.适用场景

```
1.需求变动不频繁
2.项目周期长
3.项目需要回归测试
```



#### 2.常见测试工具

```
1. QTP（收费）
        QTP是商业的功能测试工具，收费，支持web，桌面自动化测试。
2. Selenium（开源）【本阶段学习】
        Selenium是开源的web自动测试工具，免费，主要做功能测试。
3. Jmeter（开源、Web、接口、性能）
        Jmeter是由Apache公司使用Java平台开发的一款测试工具，支持（Web、接口测试、性能测试）
        提示：Web测试在通信层(无UI界面)
5. Loadrunner（收费、Web、性能）
        Loadrunner是商业性能测试工具，收费，功能强大，适合做复杂场景的性能测试
6. Robot framework
        Robot Framework是一个基于Python可扩展地(关键字驱动)的测试自动化框架；
        
        
    Web自动化测试：selenium、robot framework
    App端自动化测试：Appium、Monkeyrunner、UIautomation
    PC客户端（win32）自动化测试：QTP
    接口自动化测试：Jmeter、Postman、httpUnit、RESTClient
    云测平台：Testin Testbird
    性能测试：Jmeter、LoadRunner
```





#### webdriver

```
#1.查看chrome版本
75.0.3770.142

#2.下载对应版本的chromedriver
https://npm.taobao.org/mirrors/chromedriver

#3.配置chromedrive
将解压的chromedriver 复制到Python解释器安装目录

```





#### 3.元素定位

```
1. id
2. name
3. class_name
4. tag_name
5. link_text
6. partial_link_text
7. xpath
	补充：
	//*[text()="xxx"]                            文本内容是xxx的元素
	//*[starts-with(@attribute,'xxx')]                属性以xxx开头的元素
	//*[contains(@attribute,'Sxxx')]                属性中含有xxx的元素
8. css_selector  
	1. id选择器      #xxx
    2. class选择器   .xxx
    3. 元素选择器    "input"
    4. 属性选择器    "input[name='xxx']"   
    			   input[type^='p'] 说明：type属性以p字母开头的元素
                    input[type$='d'] 说明：type属性以d字母结束的元素
                    input[type*='w'] 说明：type属性包含w字母的元素
                    input[type~='value'] 说明: type属性包含value的元素
                    input[type=value] 说明: type属性是value的所有元素
    5. 层级选择器    "p [type='password']"
		
```



#### 4.元素操作

```
1. clear()            清除文本
2. send_keys()        模拟输入
3. click()            单击元素
4. text
5. get_attribute()
```



#### 5.webdriver常用方法及属性

```
# 方法
1. maximize_window()                 最大化 --> 模拟浏览器最大化按钮
2. set_window_size(100,100)          浏览器大小 --> 设置浏览器宽、高(像素点)
3. set_window_position(300,200)      浏览器位置 --> 设置浏览器位置
4. back()                            后退 --> 模拟浏览器后退按钮
5. forward()                         前进 --> 模拟浏览器前进按钮
6. refresh()                         刷新 --> 模拟浏览器F5刷新
7. close()                           关闭 --> 模拟浏览器关闭按钮(关闭单个窗口)
8. quit()                            关闭 --> 关闭所有WebDriver启动的窗口
9. save_screenshot()                 保存截图

# 属性
title
current_url

```



#### 6.显示等待和隐式等待

```
# 显示等待(了解)
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
url = r'E:\测试\课件\Web自动化\Web自动化课件\02img\注册A.html'
driver = webdriver.Firefox()
driver.get(url)
element = WebDriverWait(driver, 5).until(EC.presence_of_element_located((By.ID, 'userA')))
element.send_keys("admin")


# 隐式等待
driver.implicitly_wait(10)
```



#### 7.鼠标和键盘操作

```
# 鼠标
1. context_click()          右击 --> 此方法模拟鼠标右键点击效果
2. double_click()           双击 --> 此方法模拟双标双击效果
3. drag_and_drop()          拖动 --> 此方法模拟双标拖动效果
4. move_to_element()        悬停 --> 此方法模拟鼠标悬停效果
5. perform()                执行 --> 此方法用来执行以上所有鼠标方法    

例子：
	from selenium.webdriver.common.action_chains import ActionChains
	Action=ActionChains(driver)
	element=Action.context_click(username)
	element.perform()

# 键盘
1. send_keys(Keys.BACK_SPACE)删除键（BackSpace） 
2. send_keys(Keys.SPACE)空格键(Space) 
3. send_keys(Keys.TAB)制表键(Tab) 
4. send_keys(Keys.ESCAPE)回退键（Esc） 
5. send_keys(Keys.ENTER)回车键（Enter） 
6. send_keys(Keys.CONTROL,'a') 全选（Ctrl+A） 
7. send_keys(Keys.CONTROL,'c')复制（Ctrl+C）
。。。

例子：
	from selenium.webdriver.common.keys import Keys
	element=driver.find_element_by_id("userA")
    # 输入用户名
    element.send_keys("admin1")
    # 删除1
    element.send_keys(Keys.BACK_SPACE)
    # 全选
    element.send_keys(Keys.CONTROL,'a')
    # 复制
    element.send_keys(Keys.CONTROL,'c')
    # 粘贴
    driver.find_element_by_id('passwordA').send_keys(Keys.CONTROL,'v')
```



#### 8.下拉框，警告框，滚动条

```
# 下拉框
1. select_by_index()                --> 根据option索引来定位，从0开始
2. select_by_value()                --> 根据option属性 value值来定位
3. select_by_visible_text()         --> 根据option显示文本来定位

例子：
	from selenium.webdriver.support.select import Select
	
	# 需要将找到的元素转成Select
    select=Select(driver.find_element_by_id("Selectxxx"))
    # 1. 根据索引实现
    select.select_by_index(1)
    select.select_by_index(3)
    select.select_by_index(2)
    # 2. 根据文本值实现
    select.select_by_visible_text("A上海")
    select.select_by_visible_text("A重庆")
    select.select_by_visible_text("A广州")
    # 3. 根据value属性实现
    select.select_by_value("sh")
    select.select_by_value("cq")
    select.select_by_value("gz")
    
# 警告框
    HTML中常用的对话框有三种，处理的方法都一样
        1. alert
        2. confirm
        3. prompt
        
    
    1. text                 --> 返回alert/confirm/prompt中的文字信息
    2. accept()             --> 接受对话框选项
    3. dismiss()            --> 取消对话框选项
    
    
   例子：
   		# 定位alerta按钮
        driver.find_element_by_id("alerta").click()
        # 获取警告框
        alert=driver.switch_to.alert
        # 打印警告框文本
        print(alert.text)
        # 接受警告框
        alert.accept()
        # 取消警告框
        #alert.dismiss()
    
# 滚动
例子：
    js1="window.scrollTo(0,1000)"
    driver.execute_script(js1)
```



## day07

### 自动化测试

#### 9.iframe切换

```
方法：
    1). driver.switch_to.frame("myframe1")        --> 切换表单方法
            (myframe1：为frame表单的name或id)
    2). driver.switch_to.default_content()        --> 恢复默认页面方法
    	driver.switch_to.parent_frame()
    
使用：
	1. 完成当前页面注册信息；
    2. 调用表单切换方法(switch_to.frame("myframe1"))切换到注册用户A表单中
    3. 调用恢复默认页面方法(switch_to.default_content())
    4. 调用表单切换方法(switch_to.frame("myframe2"))切换到注册用户B表单中
  
```



#### 10.window切换

```
方法：
    1). driver.current_window_handle         --> 获取当前窗口句柄
    2). driver.window_handles                 --> 获取所有窗口句柄
    3). driver.switch_to.window(handle)        --> 切换指定句柄窗口
```



#### 11.截图

```
driver.save_screenshot(imgpath)     --> 截取当前窗口    (imgpath：图片保存路径)
```



#### 12.cookie

```
方法：
    1. get_cookie(name)                 --> 获取指定cookie    (name:为健名)
    2. get_cookies()                    --> 获取本网站所有本地cookies
    3. add_cookie(str)                  --> 添加cookie        (str：为python中的字典格式)
```





#### 13.UnitTest

```
# 1. TestCase   一个TestCase就是一条测试用例
例子：
import unittest

def add(x,y):
    return x+y

class Testcase_01(unittest.TestCase):
    def setUp(self):
        print("setUp")
        # self.driver=webdriver.Chrome()

    def tearDown(self):
        print("teardown")
        # self.driver.quit()

    def test_01(self):
        print("1+1=",add(1,1))
        # self.driver.get("")
        
    def test_02(self):
        print("2+2=",add(2,2))
        # self.driver.get("")

class Testcase_02(unittest.TestCase):
    def testcase_01(self):
       print("testcase_01")


if __name__ == '__main__':
    unittest.main()
    
 	# 上面代码可以右键运行， 也可在命令行中运行
   
    
  
# 2. TestSuite  多条测试用例集合在一起，就是一个TestSuite, 通常结合TextTestRunner使用
# 3. TextTestRunner 是用来执行测试用例套件
例子：
	import unittest
    from unittest_6 import Testcase_01,Testcase_02


    # 创建测试组
    suite = unittest.TestSuite()
    # 添加测试方法
    suite.addTest(Testcase_01.test_01)
    suite.addTest(Testcase_01.test_02)
    suite.addTest(Testcase_01.test_03)
    suite.addTest(Testcase_02.testcase_01)
    suite.addTest(Testcase_02.testcase_02)
    suite.addTest(Testcase_02.testcase_03)


    # suite.addTest(unittest.makeSuite(Testcase_01))
    # suite.addTest(unittest.makeSuite(Testcase_02))

    # 创建测试运行环境
    runner=unittest.TextTestRunner()
    # 运行测试
    runner.run(suite)


# 4. Fixture   对一个测试用例环境的搭建和销毁就是一个Fixture(包含setup,teardown的 testcase)
例子：
	import unittest
    from selenium import webdriver

    def add(x,y):
        return x+y

    class Testcase_01(unittest.TestCase):
        def setUp(self):
            print("setUp")
            self.driver=webdriver.Chrome()

        def tearDown(self):
            print("teardown")
            self.driver.quit()

        def test_01(self):
            print("1+1=",add(1,1))
            # self.driver.get("")

    if __name__ == '__main__':
        unittest.main()



# defaultTestLoader  
	通过该类下面的discover()方法自动搜索指定目录下指定开头的.py文件，并将查找到的测试用例组装到测试套件
	
例子：	
	    import unittest
	    test_dir = './'
        disconver = unittest.defaultTestLoader.discover(test_dir, pattern='iweb_*.py')
        (test_dir为要指定的目录 ./为当前目录；pattern：为查找的.py文件的格式 )
    运行：
        runner=unittest.TextTestRunner()
        runner.run(disconver)

```



#### 14.断言

```
# 概念： 让程序代替人为判断测试程序执行结果是否符合预期结果的过程
# 分类： 
	1. 基本布尔型断言
    2. 比较断言 
    3. 复杂断言
    
# 基本布尔断言
序号	断言方法	断言描述
1	assertEqual(arg1, arg2, msg=None)	验证arg1=arg2，不等则fail 【掌握】
2	assertNotEqual(arg1, arg2, msg=None)	验证arg1 != arg2, 相等则fail
3	assertTrue(expr, msg=None)	验证expr是true，如果为false，则fail
4	assertFalse(expr,msg=None)	验证expr是false，如果为true，则fail
5	assertIsNone(expr, msg=None)	验证expr是None，不是则fail
6	assertIsNotNone(expr, msg=None)	验证expr不是None，是则fail
7	assertIn(arg1, arg2, msg=None)	验证arg1是arg2的子串，不是则fail【掌握】

例子：
	
	import unittest
    def add(x,y):
        return x*y

    class TestCase_01(unittest.TestCase):

        def test_01(self):
            # 断言相等  arg1 期望的值  arg2 实际结果
            self.assertEqual(2,add(1,1))

        def test_01(self):
            self.assertIn("ac","abcdefg")


    if __name__ == '__main__':
        unittest.main()
```



#### 15.测试报告

```
1. Export Test Results （UnitTest 自带）  pycharm中点击相应按钮
2. HTMLTestRunner（第三方模板）【重点】  拷贝该py文件即可，运行即可

例子：
import unittest
from tools.HTMLTestRunner import HTMLTestRunner

suite=unittest.defaultTestLoader.discover("./cases",pattern="testcase_*.py")
with open("./reports/测试报告.html","wb") as f:  
    runner=HTMLTestRunner(stream=f,title="测试报告",description="测试用例")
    runner.run(suite)
	
```



### iwebshop

```
# 1.通过selenium 登录测试

# 2.unittest 
```





## day08

### 学生管理系统(***)

#### 1.准备工作

```
1. 安装python解释器  推荐python3.5以上版本(已有可忽略)
2. (可通过pycharm创建虚拟环境)安装依赖模块：pip install -r requirements.txt -i https://pypi.douban.com/simple
3. 命令行运行：python run_server.py
4. 浏览器访问 127.0.0.1:8000


# chrome 浏览器先安装json 插件(jsonview 或者  json-handle)
# 电脑上安装 postman
```



#### 2.熟悉接口文档

```
见资料中  api文档

# 注意：
queries 
多个    $dep_id_list=T01,T02
单个    dep_name=xxx   master_name=Java-Master
模糊    blur=1 或者不写

```



#### 3.postman增删改查测试

```
# 学院
## 查询所有  get http://127.0.0.1:8000/api/departments/
## 查询列表  get http://127.0.0.1:8000/api/departments?$dep_id_list=T01,T02
## 查询单个  get  http://127.0.0.1:8000/api/departments?master_name=Java-Master
## 查询模糊  get  http://127.0.0.1:8000/api/departments?master_name=Java&blur=1
## 新增      post http://127.0.0.1:8000/api/departments/  
body   raw  json

{
   "data": [{
    "dep_id": "T100",
    "dep_name": "Test学院",
    "master_name": "Test-Master",
    "slogan": "Here is Slogan"
	}]
}


## 修改   put   http://127.0.0.1:8000/api/departments/T100/ 
body   raw  json

{
   "data": [{
    "dep_name": "Test学院111",
    "master_name": "Test-Master",
    "slogan": "Here is Slogan"
	}]
}

## 删除  delete   http://127.0.0.1:8000/api/departments/T100/

# 班级
## 所有 get http://127.0.0.1:8000/api/departments/T01/classes/
## 列表 get http://127.0.0.1:8000/api/departments/T01/classes/?$cls_id_list=2017T01C01,2017T01C02
## 单个 get http://127.0.0.1:8000/api/departments/T01/classes/?cls_name=2018级Test学院T01班

```



#### 4.jmeter

```
# 基本认识

# 作用
web自动化
接口测试
性能测试
压力测试
使用jdbc进行数据库测试

# jdk安装
点击下载的jdk 可执行文件，安装
配置环境变量
	我的电脑---属性---高级设置---环境变量---新建JAVA_HOME="jdk路径"---点击path,
	添加JAVA_HOME, %JAVA_HOME%\bin
	
命令行测试
	java -version  
	javac -version
	
# jmeter安装及启动
已提供，直接解压，进到bin, 点击 jmeter.bat 或者 ApacheJMeter.jar


# jmeter.property
encoding=utf-8
```



##### 4.1 基本使用

```
添加线程组---选中线程组，添加取样器，http请求---选中线程组，添加监听器，查看结果树---选中线程组，添加监听器，聚合报告

运行(如果乱码，更改jmeter.property encoding=utf-8，并重启jmeter)

注意事项：ip那里不要带前缀, 只写ip
```



##### 4.2 测试计划和线程组

```


```

##### 4.3 测试片段

```
1.跟线程组是同级别，
2.不会直接运行，要运行，需要现在线程组中添加(逻辑控制器)模块控制器
3.线程组中的先运行，测试片段后运行
```



##### 4.4 元件

```
# 八大元件及其作用域
取样器： 任何时候都会执行
逻辑控制器： 对子元件有绝对的控制权

其他6个，如果父类是取样器，只对父元件起作用，如果父类不是取样器，对所有子类起作用


# 执行顺序(从上往下)
配置元件(请求头等)
前置处理器(用户参数等)
定时器
取样器(http请求等)
后置处理器(json提取器等)
断言(判断结果等)
监听器(结果展示，汇总等)
```



## day09

#### 4.jmeter

##### 4.5参数化

###### 4.5.1csv

```
# 概念
动态的获取或设置数据(可以不同的用户不同的参数)

# csv（逗号分隔值文件）
name,age,hobby
zhangsan,18,dotest

# 添加csv文件
线程组---添加配置元件---csv文件数据文件配置
csv数据文件设置---文件名，文件编码，变量名称
http请求---参数，添加，值($name等)
修改线程组的线程数

遇到文件结束符再次循环 true/false   false
遇到文件结束符停止线程 true/false   true
```



###### 4.5.2用户参数

```
# 适用于参数较小的场景

# 添加用户参数
线程组---前置处理器---用户参数
添加变量，添加用户
http请求---参数，添加，值($name等)
更改测试计划的线程数

# 添加用户自定义参数
线程组---配置元件---用户定义的变量
添加(名称，值)
http请求---参数，添加，值($name等)
更改测试计划的线程数

# 学生管理系统案例
见资料 参数化学院系统.jmx  参数化学院删除.jmx

删除：
	选项---函数生成助手
	先生成counter，再添加intsum
   	${__intSum(${__counter(false\,)},665,)}
```



##### 4.6数据库

```
# 连接数据库，需要相应的驱动，并将其放到jmeter lib目录下

# 添加sqlite数据库
添加线程组---添加配置文件---添加jdbc connection configuration
更改配置文件名，最大连接数
database url:
	jdbc:sqlite:D:\\资料\\自动化测试\\4接口测试\\1-教学资料\\项目\\studentManagementSystem\\db.sqlite3

jdbc Driver class : 
	org.sqlite.jdbc
	
	
线程组---取样器---jdbc request
输入mysqlite
query type: update / select statement  （增删改查），并输入查询语句
添加查看结果树


# 添加mysql数据库
Database url: jdbc:mysql://127.0.0.1:3307/iwebshop
jdbc Driver class: com.mysql.jdbc.Driver
Username:root


# oracle数据库
Database url: jdbc:oracle:thin:@localhost:1521:orcl
jdbc Driver class: oracle.jdbc.OracleDriver
Username:xxx
Password:yyy
```



##### 4.7关联

```
# 概念
一个请求需要用到另一个响应的结果

# 添加关联（见资料关联.jmx）
## 正则
## xpath  记得勾选use tidy
	用$$引用起来，如果在正则表达式中有多个正则表达式（多个括号括起来的东东），则可以是$2$$3$等等，表示解析到的第几个值给title。如：$1$表示解析到的第1个值
## json   

```



##### 4.8断言

```
#  几个基本概念
apply to：是应用范围，设定匹配的范围
    Main sample and sub-samples:匹配范围为当前父取样器，及子取样器
    Main sample only ：仅当前父取样器
    Sub samples only:仅子取样器
    JMeter Variable：变量值进行匹配

要测试的响应文字：针对响应数据不同部分进行匹配
    响应文本：响应服务器返回的文本内容，http协议排除header部分
    响应代码：匹配响应代码，比如http请求中'200'代表成功, 状态码
    响应信息：匹配响应信息，处理成功返回"Found"或者“OK”字样,区分大小写
    Response Header:匹配响应头中的信息  （包括/substring 200,ok)

匹配规则：
    包括：响应内容包括需要匹配的内容就算成功
    匹配：响应内容要完全匹配匹配内容，不区分大小写
    equals：完全相等，区分大小写
    substring：响应内容包括匹配内容即为成功。




# 响应断言    响应代码---equals---200/400/404  ; 响应文本---substring---百度一下
	注意事项： 响应文本 包括，匹配可以用正则，equals,substring 不支持正则(当做完整字符串)
# 大小断言   
	full response
	response headers
	response body

# 断言持续时间 断言成功的最大时间
```



##### 4.9集合点

```
# 添加集合点
线程组---定时器---synchroning timer

number of simulated Users to Group By : 10 （集结10个再运行）
Timeout in milliseconds: 1000 （1s内集结完成）
```



##### 4.10常用函数

```
counter  计数器
intsum   加法
csvRead  第一个参数: 文件路径，第二个参数：csv中的第几列， 编码存在问题，只支持ascii
Random   
time

setProperty 把指定数据设置成Jmeter属性(全局变量)
	线程组---取样器---bean shell取样器---脚本(函数助手)
Property    获取上面设置的全局变量(脚本(函数助手))
	
```





## day10

### 1.分布式

基本概念

```
# 现状
按照一般的压力机配置，jmeter的GUI模式下（Windows），最多支持300左右的模拟请求线程**，再大的话，容易造成卡顿、无响应等情况，这是限于jmeter其本身的机制和硬件配置。

有时候为了尽量模拟业务场景，需要模拟大量的并发请求，这个时候单台压力机就显得有心无力。针对这个情况，jmeter的解决方案是支持分布式压测，即将大量的模拟并发分配给多台压力机，来满足这种大流量的并发请求场景。


# 解决办法
分布式

# 分布式执行原理
1. 一台电脑作为控制机(Controller)，其它电脑做为执行机(Agent);
2. 执行时，控制机会把脚本发送到每台执行机上，执行机拿到脚本后就开始执行
3. 执行机执行时不需要启动Jmeter界面，可以理解它是通过命令行模式执行的
4. 执行完成后，执行机会把结果回传给控制机，控制机会收集所有执行机的信息并汇总

```



操作步骤

1.执行机Jmeter.properties配置

```
1. 分别打开执行机下jmeter安装文件下的bin目录:jmeter.properties, 找到server_port
2. server_Port=1099.    1099为执行机自定义端口号(另一台配置为1100)
3. 注意:
    - 要取消注释符号 #
    - 自定义的端口号,要选择未被占用的端口号
    
    
    
```



2.控制机jmeter.properties配置

```
1.打开控制机下jmeter安装文件下的bin目录:jmeter.properties,找搭配remote_hosts
2. remote_hosts=127.0.0.1:1099,127.0.0.1:1100
3. 注意事项:
   - 多个执行机的ip间要用全英文的半角逗号隔开
```



3.执行机启动分布式

```
1. 分别运行bin目录下jmeter-server.bat
2. 运行后勿关闭黑色窗口
```



4.控制机-线程数设置

```
线程组---取样器---http请求 
需求1000用户,两台执行机同时接受控制机脚本去执行然后反馈给控制机，所以(线程组)线程数设置500
```



5.控制机运行

```
点击菜单栏---运行---远程启动全部
```



注意事项：

```
1. 修改完端口要重启Jmeter.bat
2. 控制机和执行机分开(为了方便教学,这里采用控制机和代理机在1台机器上)
   1). 由于控制机需要发送信息给执行机并且会接受执行机回传的测试数据所以控制机自身会有消耗
3. 参数文件：如果使用csv进行参数化，那么需要把参数文件在每台执行机上拷一份且路径需要设置成一样的；
4. 每台机器上安装的Jmeter版本和插件最好都一致，否则会出一些意外的问题；
5. 执行机上Jmeter也许需要配置JDK环境变量；
```





### 2.逻辑控制器

#### 2.1 if控制器

```
# 作用
条件成真,则执行控制器下所有取样器

# 操作
1. 测试计划->线程组
1. 测试计划->用户自定义变量
2. 线程组->如果（If）控制器
3. 如果（If）控制器->HTTP请求
4. 测试计划-察看结果树


# 注意点
1. 条件:"${name}"=="百度"
2. 注意：
    1) 引用变量格式${name}需要被双引号括起来
    2) 两个等号
    3) 值需要被双引号括起来
```



#### 2.2 ForEach控制器

```
# 作用
ForEach控制器一般和用户定义的变量一起使用，在用户自定义变量中读取一系列相关的变量。

# 操作
1. 测试计划->线程组
2. 线程组->用户定义的变量
3. 线程组->ForEach控制器
4. ForEach控制器->HTTP请求
5. 测试计划->察看结果树

# 注意点
1. 输入前缀变量：输入要遍历变量前缀(name)
2. 开始循环字段(不包含):遍历变量开始的索引    0(从1开始)   
3. 结束循环字段(包含):遍历变量结束的索引      3
4. 输出变量名称:定义要被引用的变量名称    name(该name用于在http请求中的值)
```



#### 2.3 交替控制器

```
# 作用：交替控制，该控制器包含的所有取样器，步骤交错执行在每个循环

# 操作
1. 测试计划->线程组
2. 线程组->HTTP请求(查询学院-所有)
3. 线程组->交替控制器
4. 交替控制器->HTTP请求(查询学院-指定)
5. 交替控制器->HTTP请求(查询学院-id_list)


注意线程组的设置 循环次数
```



#### 2.4 循环控制器

```
# 作用：指定循环控制器内取样器的执行次数

# 操作
1. 测试计划->线程组
2. 线程组->循环控制器
3. 循环控制器->HTTP请求(查询学院-所有)
4. 测试计划->察看结果树

```

#### 2.5 仅一次控制器

```
# 如果线程组 循环次数开启了10， 则只运行一次
```



#### 2.6随机控制器和随机顺序控制器

```
# 随机控制器： 从几个请求中随机选择一个
# 随机顺序控制器： 将几个请求都执行，但是顺序随机
```



#### 2.7 while控制器

```
# 注意事项
1. 为空：最后一个请求失败，停止循环；(如果不是最后一个请求执行失败，则继续循环)
2. LAST：
    1) 与为空相同之处：最后一个请求失败，停止循环；(如果不是最后一个请求执行失败，则继续循环)
    2) 与为空不同之处：测试计划在执行while控制器之前如果有请求失败，则不会执行while控制器
3. 表达式：表达式为false退出循环；
    例如：
        1) ${VAR}:当参数VAR的值被设置成false时退出循环
        2) ${__javascript(“${VAR}”==”User1”)}:当参数VAR的值部位User1时退出循环
```



#### 2.8 switch控制器

```
# 作用：通过给该控制器中的value赋值，来指定运行哪个取样器;
# 注意事项
1. Switch Value：为采样器名称；执行采样器名称相应的请求
2. Switch Value：为空；默认为执行第一个
3. Switch Value：为索引；第一个为0

```

#### 2.9 简单控制器

```
# 作用：只做分组使用，犹如打隔断；
```



#### 2.10 事务控制器

```
# 作用：生成一个额外的采样器来测量其下测试元素的总体时间； 
       值得注意的是，这个时间包含该控制器范围内的所有处理时间，而不仅仅是采样器的
       如果事务控制器下的某一个请求失败，可改事务失败
       
       如果勾选了事务控制器中的选项， 则结果展示会以树形结果进行展示
      
```



### 3.功能脚本设计

见 资料代码---学院功能脚本

```
# http 请求默认值  get  127.0.0.1  8000 utf-8
# http 信息头管理器    Content-Type

# 查询
# 新增
# 更新
# 删除(单个，列表)
```



### 4.接口测试用例及参数设计 

> 上面功能脚本设计只是正常的参数设计，还没有特殊情况的考虑，故有了下面正向，逆向参数设计等



见课件

```
# 测试用例设计原则
1. 覆盖所有的必选参数
2. 组合可选参数
3. 参数边界值
4. 如果参数的取值范围是枚举变量，需要覆盖所有枚举值    
5. 空数据
6. 包含特殊的字符
7. 越界的数据
8. 错误的数据


# 用例格式
用例编号	用例名称	方法	测试步骤	预期结果	是否通过	备注

# 测试数据
## 正向方法
1. 传入所有可传属性，且格式正确
2. 传入必填属性，且格式正确

## 校验方法
1) 为空校验
2) 为空格校验
3) 前后含空格校验
4) 超长校验
5) 类型校验
6) 含特殊字符校验
7) 删除引用校验
8) 唯一不重复属性校验

例子：学院-组合查询参数化示例

Here is Slogan,Test-Master,Test学院,----正向数据
,Test-Master,Test学院,----两个条件组合
,,Test学院,----单个条件
Here is Slogan,,,----正向数据
,Test-Master,,----正向数据
 Here is Slogan ,Test-Master,Test学院,----Here is Slogan前后含空格
Here is Slogan, Test-Master ,Test学院,----Test-Master前后含空格
Here is Slogan,Test-Master, Test学院 ,----Test学院前后含空格
 ,Test-Master,Test学院,----为空格
Here is Slogan, ,Test学院,----为空格
Here is Slogan,Test-Master, ,----为空格
Here is Slogan222,Test-Master,Test学院,----一个条件不存在
Here is Slogan,Test-Master22222222222222222222222222222,Test学院,----超长
Here is Slogan,Test-Master,Test%%%%%%%%%%%%%院,----含特殊字符
,,,----全部为空


```



### 5.自动化测试设计

```
# 为什么要设计自动化脚本？
后台程序更新/发布新版之前需要验证下之前的功能是否能用

# 分析
1. 使用数据库连接池
2. 使用setUp Thread Group线程组
3. 使用tearDown Thread Group线程组
4. 使用线程组
5. 使用函数
6. 使用关联
7. 添加断言
8. 使用sampler中请求
9. 添加聚合报告

# 新增，删除
使用数据库配置信息， jdbc信息 ，添加响应断言

# 查询
# 更新
```



### 6.性能脚本设计

```
# 聚合报告
# 汇总报告

聚合报告说明：
1. Label:在不勾选"Include group name in label?"复选框的情况下，为请求取样器的名称，
    否则为“请求取样器所在线程组:请求取样器名称”
2. Samples:用同一个请求取样器，发送请求的数量(注意：该值是不断累计的)。
    比如，10个线程数设置为10，迭代10次，那么每运行一次测试，该值就增加10*10=100
3. Average:请求的平均响应时间
4. Median:中位数。50%的样本都没有超过这个时间。
    这个值是指把所有数据按由小到大将其排列，就是排列在第50%的值。
5. 90% Line：90%的样本都没有超过这个时间。这个值是指把所有数据按由小到大将其排列，就是排列在第90%的值。
6. Min:针对同一请求取样器，请求样本的最小响应时间
7. Max:针对同一请求取样器，请求样本的最大响应时间
8. Error %:出现错误的请求样本的百分比
9. Throughput：吞吐量以“requests/second、requests /minute、requests /hour”来衡量。
    时间单位已经被选取为second，所以，显示速率至少是1.0，即每秒1个请求。
10. Received KB/sec - 收到的千字节每秒的吞吐量测试。
11. Kb/sec - 以Kilobytes/seond来衡量的吞吐量(发送的千字节每秒的吞吐量测试)
```



### 7.生成文档

```
# 无日志文件生成
jmeter -n -t <test JMX file> -l <test log file> -e -o <Path to output folder>

参数详解：
-n ：以非GUI形式运行Jmeter

-t ：source.jmx 脚本路径

-l ：运行结果保存路径（.jtl）,此文件

必须不存在

  1) .jtl
  2) .txt
  3) 无后缀
-e ：在脚本运行结束后生成html报告

-o ：保存html报告的地址, 此文件必须不存在



例子：jmeter -n -t E:\课件\Jmeter\Script\自动化脚本\Stu_AutoScript.jmx -l E:\课件\Jmeter\Script\自动化脚本\testLog -e -o E:\课件\Jmeter\Script\自动化脚本\report

最终文件目录效果：
	自动化脚本
		Stu_AutoScript.jmx
		testlog
		report
			xx
			xx
			xx
		


# 使用已有的jtl日志文件或csv日志文件生成
jmeter -g <log file> -o <Path to output folder>

例子：jmeter -g E:\课件\Jmeter\Script\自动化脚本\resultt.jtl -o ./outputreport
```





## day11

### 1.环境搭建

#### 1.1java环境

> 见课件

#### 1.2android sdk 环境

> 见课件

#### 1.3模拟器

> 直接用夜神模拟器



### 2.adb指令

```
# 获取设备号
adb devices

# 连接夜神模拟器
cd 夜神模拟器目录（如果将夜神模拟器添加到了环境变量， 此步骤可省略）
nox_adb.exe connect 127.0.0.1:62001

# 安装app到手机

adb install (-r) 路径/xxx.apk                 -r：替换已有的应有安装

# 卸载手机app 包名
adb uninstall 包名

# 获取app启动包名和启动名(⚠手机需要先打开对应app)
1.Mac/Linux: 'adb shell dumpsys window windows | grep mFocusedApp’
2.在 Windows 终端运⾏ 'adb shell dumpsys window windows | findstr mFocusedApp’


*************************上面必须掌握******************************

# 进入到手机终端
adb shell

# 发送文件到手机
adb push 电脑端⽂件路径/需要发送的文件,手机端存储的路径

adb push C:\Users\win\Desktop\xx.png /sdcard


# 从手机拉取文件
adb pull 手机端的路径/拉取文件名 电脑端存储文件路径

adb pull /sdcard/xx.png C:\Users\win\Desktop

# 查看手机运行日志
adb logcat

# 获取系统版本
adb shell getprop ro.build.version.release

#启动adb 服务
adb start-server

# 关闭adb 服务
adb kill-server

```



**补充：**

```
#  安卓手机目录参考 
https://blog.csdn.net/viking_xhg/article/details/81102600

# 安卓手机文件管理器    
es文件浏览器

# 如何安装同时通过微信传的apk文件？

# 如果给一台手机安装多个应用
for %f in (C:\Users\H\Desktop\*.apk) do adb install "%f"
```



### 3.appnium

#### 3.1安装

```
# 简介
Appium是由nodejs的express框架写的Http Server
Appium使用WebDriver的json wire协议，
来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架

# 原理
python代码---> appnium server---> uiautomation/uiautomator 库 ---> 操作手机

# 安装客户端(参考爬虫课件)
安装nodejs
安装appnium客户端

# appnium python 库安装
pip install Appium-Python-Client 
```



#### 3.2使用

```
# 前置代码
from appium import webdriver

# driver=webdriver.Chrome()
# 所有的手机的信息
desired_caps={}
# 系统的名称
desired_caps["platformName"]="Android"
# 系统的版本
desired_caps["platformVersion"]="4.4.2"

# 设备的名字
desired_caps["deviceName"]="127.0.0.1:62001"

# 启动app
desired_caps["appPackage"]="com.android.settings"
# 界面名
desired_caps["appActivity"]=".Settings"

driver=webdriver.Remote("http://127.0.0.1:4723/wd/hub",desired_caps)



# 安装apk到手机
driver.install_app(app_path)

参数：app_path：APK文件所在路径

举例:
driver.install_app(r"D:\Users\Day01\02\login.apk")
driver.install_app(os.getcwd() + os.sep + "login.apk")

# 卸载手机中app
driver.remove_app(app_id)
参数：app_id：需要卸载的app包名

举例:
driver.remove_app("com.itheima.login")


# 判断app是否已经安装
driver.is_app_installed(bundle_id)
参数：bundle_id: 可以传入app包名,返回结果为True(已安装) / False(未安装)

示例:
result=driver.is_app_installed("com.itheima.login")
print(result)
if result : 
	driver.remove_app("com.itheima.login")
else : 
	driver.install_app(os.getcwd() + os.sep + "login.apk")
	
# 发送文件到手机
with open("abcd.txt", "r") as f:
    data = f.read() #读取文件中全部内容
    # base64编码
    b64_data = str(base64.b64encode(data.encode("utf-8")), "utf-8")
    # 发送文件到手机 指定名字
    driver.push_file("/sdcard/hello.txt", b64_data)
    
# 从手机里面拉取文件
data = driver.pull_file("/sdcard/hello.txt")
print(data)
# 解码base64数据
print(str(base64.b64decode(data), "utf-8"))


# 获取当前屏幕内的元素结构
page_data = driver.page_source
if "显示" in page_data:
    print("进入设置页面")
else:
    print("没进入设置页面")
   
```



#### 3.3uiautomatorviewer

> 界面元素找不到的解决办法 <https://blog.csdn.net/windyoyo/article/details/51388984>

```
# 作用
用来扫描和分析Android应用程序的UI控件的工具.

# 使用
1.进入SDK目录下的tools目录，打开uiautomatorviewer
2.电脑连接真机或打开android模拟器
3.启动待测试app
4.点击uiautomatorviewer的左上⻆Device Screenshot,会生成app的UI控件截图
5.选择截图上需要查看的控件，即可浏览该控件的id,class,text,坐标等信息


注意：
只能获取静态页面的结构
```



#### 3.4定位元素

```
# id
例子：
	driver.find_element_by_id("com.android.settings:id/search").click()
	
# class
例子：
	driver.find_element_by_class_name("android.widget.ImageButton").click()
	
# xpath
	driver.find_element_by_xpath("//*[contains(@text,'WLA')]").click()

```



#### 3.5显示等待

```
# 说明
在一个超时时间范围内，每隔一段时间去搜索一次元素是否存在，
如果存在返回定位对象，如果不存在直到超时时间到达，报超时异常错误

time.sleep()
```



## day12

### 1.元素获取

```
# 发送数据到输入框
send_keys

driver.find_element_by_id("android:id/search_src_text").send_keys("abc")

注: 如果插入中文,需要在desired_caps里面增加2个参数:
desired_caps['unicodeKeyboard'] = True
desired_caps['resetKeyboard'] = True
driver.find_element_by_id("com.android.settings:id/search").click()
driver.find_element_by_id("android:id/search_src_text").send_keys("百度")

# 清空输入框内容
clear()

input_text = driver.find_element_by_id("android:id/search_src_text")
input_text.send_keys("abc")
time.sleep(1)
input_text.clear()

#  获取元素的文本内容
text

# 获取元素的属性值
get_attribute(value) # value:元素的属性

# 获取元素在屏幕上的坐标
location

例子：
    #定位搜索按钮
    get_value = driver.find_element_by_id("com.android.settings:id/search")
    #输出按钮坐标
    print(get_value.location)


# 获取app包名和启动名
获取包名方法: current_package
获取启动名: current_activity

需求:
    启动设置,获取包名和启动名
    print(driver.current_package)
    print(driver.current_activity)
```



### 2.元素事件

```
#  swip滑动事件
从一个坐标位置滑动到另⼀个坐标位置,是两个点之间的滑动.

方法: swipe(start_x, start_y, end_x, end_y, duration=None)
参数解释:
1.start_x：起点X轴坐标
2.start_y：起点Y轴坐标
3.end_x： 终点X轴坐标
4.end_y,： 终点Y轴坐标
5.duration： 滑动这个操作一共持续的时间长度，单位：ms
例如: driver.swipe(144,1017,144,444,2000)

需求:
 进入设置,从存储滑动到更多

# 找到存储和更多坐标
save = driver.find_element_by_xpath("//*[contains(@text,'存储')]").location
more = driver.find_element_by_xpath("//*[contains(@text,'更多')]").location
# 移动
driver.swipe(save[‘x’], save[“y”], more[“x”], more[“y”], 2000)



# scroll滚动事件
从一个元素滚动到另外一个元素,直到页面自动停止

方法: scroll(origin_el, destination_el)
参数:
1. origin_el:开始位置
2. destination_el: 结束元素

需求:
  进入设置页,模拟手指从存储菜单位置到WLAN菜单位置上滑动操作

el1 = driver.find_element_by_xpath("//*[contains(@text,'存储')]")
# 定位到WLAN菜单栏
el2 = driver.find_element_by_xpath("//*[contains(@text,'WLAN')]")
# 执行滑动操作
driver.scroll(el1,el2)



# drag拖拽事件
从一个元素滑动到另外一个元素,第二个元素替代第一个元素原本屏幕上的位置

方法: drag_and_drop(origin_el, destination_el)
参数:
1. origin_el:开始位置
2. destination_el: 结束元素

需求: 
    进入设置页,模拟手指将存储菜单 滑动到 WLAN菜单栏位置

el1 = driver.find_element_by_xpath("//*[contains(@text,'存储')]")
# 定位到WLAN菜单栏
el2 = driver.find_element_by_xpath("//*[contains(@text,'WLAN')]")
# 执行滑动操作
driver.drag_and_drop(el1,el2)


# 将应用置于后台事件
方法: background_app(seconds)
参数:
 seconds: 停留在后台时间,单位,秒

需求:
    进入设置,将app至于后台5s

driver.background_app(5)
```



### 3.模拟手势事件

```
#1.手指轻敲操作
模拟手指轻敲一下屏幕操作

方法: 
            tap(element=None, x=None, y=None)
            perform() # 发送命令到服务器执行操作

参数:
    1.element：被定位到的元素
    2.x：相对于元素左上⻆的坐标，通常会使⽤元素的X轴坐标
    3.y：通常会使用元素的Y轴坐标

需求:
    进入设置,点击wlan选项

代码:
# 通过元素定位方式敲击屏幕
el = driver.find_element_by_xpath("//*[contains(@text,'WLAN')]")
TouchAction(driver).tap(el).perform()
# 通过坐标方式敲击屏幕，WLAN坐标:x=149,y=324
# TouchAction(driver).tap(x=149,y=324).perform()



#2.手指按下操作
方法:
    press(el=None, x=None, y=None)
    release() # 结束动作，手指离开屏幕

参数:
    1.element：被定位到的元素
    2.x：通常会使用元素的X轴坐标
    3.y：通常会使用元素的Y轴坐标

需求:
    进入设置,点击wlan选项

代码:

# 通过元素定位方式按下屏幕
el = driver.find_element_by_xpath("//*[contains(@text,'WLAN')]")
TouchAction(driver).press(el).release().perform()



#3.等待操作
方法:
    wait(ms=0)
参数:
    ms暂停的毫秒数

需求:
    进入设置,点击wlan选项,长按wiredSSID选项5秒

代码:
    driver.find_element_by_xpath("//*[contains(@text,'WLAN')]").click()
    el = driver.find_element_by_id("android:id/title")
    TouchAction(driver).press(el).wait(3000).release().perform()
    
    
#4.手指长按操作
方法:
    long_press(el=None, x=None, y=None, duration=1000)
参数:
    1.element：被定位到的元素
  2.x：通常会使用元素的X轴坐标
  3.y：通常会使用元素的Y轴坐标
  4.duration：持续时间，默认为1000ms

需求:
    进入设置、点击wlan选项、长按wired选项5秒
代码:
            # 点击WLAN
      driver.find_element_by_xpath("//*[contains(@text,'WLAN')]").click()
      # 定位到WiredSSID
      el =driver.find_element_by_id("android:id/title")
      # 通过元素定位方式长按元素
      TouchAction(driver).long_press(el,duration=5000).release().perform()

      # 通过坐标方式长按元素，WiredSSID坐标:x=770,y=667
      # 添加等待(有长按)／不添加等待(无长按效果)
      # TouchAction(driver).long_press(x=770,y=667).perform()
      


注意：
	move_to使用相对坐标时，不要使用wait
```



### 4.其他

```
#1.获取手机时间
方法:device_time 

代码:
# 获取当前手机的时间
print(driver.device_time)


#2.获取手机宽高
方法：get_window_size()

代码实现：
print(driver.get_window_size())


#3.发送键到设备
模拟系统键值操作,比如home键,音量键,返回键等.

方法:keyevent(keycode, metastate=None):

参数：
    keycode：发送给设备的关键代码
    metastate：关于被发送的关键代码的元信息，⼀般为默认值

示例:打开设置,按多次音量增加键
代码实现:

for i in range(3):
        driver.keyevent(24)
        
        
        
#4.操作手机通知栏
方法: open_notifications()

需求:
    启动设置、打开通知栏

代码实现:
driver.open_notifications()


#5.获取当前手机网络
方法:network_connection 

示例:获取当前手机网络模式 

代码实现：
print(driver.network_connection)



#6.设置手机网络
更改手机的网络模式,模拟特殊网络情况
0 没有网络 1 飞行模式 2 只有wifi  4 只有移动数据  6  所有网络齐全

方法:set_network_connection(connectionType)
参数:connectionType：需要被设置成为的⽹络类型

示例:
    启动设置,设置手机网络为飞行模式.
代码实现:
driver.set_network_connection(1)



#7.手机截图
截取 手机当前屏幕,保存指定格式图片到指定位置

方法:get_screenshot_as_file(filename)
参数：
filename：指定路径下，指定格式的图⽚.

需求:
    打开设置页面,截图当前页面,命名为screen.png

代码实现:
import os
driver.get_screenshot_as_file(os.getcwd() + os.sep + './screen.png')
```







## day13

### 1.简单使用

> 注意：方法以test开头

```
import pytest

def test_a():
    print("---->test_a") 

def test_b():
    print("---->test_b")


class Test_abc():

    def test_a(self):
        print("--------test_a----------")

    def test_b(self):
        print("--------test_a----------")

    def test_c(self):
        print("--------test_a----------")


if __name__ == "__main__":
    pytest.main(["-s. test_abc.py"])
    
# 运行方式一：
右键运行

# 运行方式二（命令行）：
pytest test_abc.py
```



### 2.setup 和 teardown

```
#1.函数级别  每个测试函数都有自己的setup和teardown 
import pytest
class Test_ABC:
        def setup(self):
            print("-----> setup_method")

        def teardown(self):
            print("----> teardown_method")

        def test_a(self):
            print("----> test_a")
            assert 1

        def test_b(self):
            print("----> test_b")

if __name__ == "__main__":
        pytest.main("-s test02.py")
        
        
        
#2.类级别  不关心测试类内有多少个测试函数
import pytest
class Test_ABC:

    def setup_class(self):
          print("-----> setup_class")

    def teardown_class(self):
          print("----> teardown_class")

    def test_a(self):
          print("----> test_a")
        assert 1

    def test_b(self):
          print("----> test_b")


if __name == "__main__":
      pytest.main("-s test_abc.py")
```



### 3.配置文件

```
# pytest.ini

[pytest]

# 配置pytest命令行运行参数
addopts = -s ... # 空格分隔，可添加多个命令行参数 -所有参数均为插件包的参数

# 配置测试搜索的路径
testpaths = ./scripts   # 当前目录下的scrip文件夹  可自定义  


# 配置测试搜索的文件名
python_files = test_*.py   # 当前目录下的scripts文件夹下，以test_开头，以.py结尾的所有文件 -可自定义


# 配置测试搜索的测试类名
python_classes = Test_*   # 当前目录下的scripts文件夹下，以test_开头，以.py结尾的所有文件中，以Test_开头的类


# 配置测试搜索的测试函数名
python_functions = test_*  #当前目录下的scripts文件夹下，以test_开头，以.py结尾的所有文件中，以Test_开头的类内，以test_开头的⽅法 -可自定义



运行(命令行): pytest
```



### 4.插件

> 插件列表 <https://plugincompat.herokuapp.com/



准备工作：

pytest.ini

```
[pytest]
# 命令行参数
addopts = -s
# 搜索文件名
python_files = test_*.py
# 搜索的类名
python_classes = Test_*
# 搜索的函数名
python_functions = test_*
```



#### 4.1 生成测试报告

```
# 1.安装三方包
 pip install pytest-html
 
# 2.生成报告
pytest —html=存储路径/report.html
```



#### 4.2 控制函数的执行顺序

```
# 1.安装三方包
 pip install pytest-ordering
 
# 2.使用方法
标记于被测函数, @pytest.mark.run(order=x)
根据order传入参数来决定运行顺序:
    order值全为正数或全为负数时, 值越小,优先级越高
    正数和负数同时存在,正数优先级高
    负数  么有标记的先执行 然后再执行标记的
    
# 3.代码示例
    @pytest.mark.run(order=2)
    def test_a(self):
        print("<<<<<<<<test_a>>>>>>>>>")

    @pytest.mark.run(order=-3)
    def test_b(self):
        print("<<<<<<<<test_b>>>>>>>>>")

    @pytest.mark.run(order=-1)
    def test_c(self):
        print("<<<<<<<<test_c>>>>>>>>>")
```



#### 4.3 失败重连

```
# 1.安装三方包
pip install pytest-rerunfailures

# 2.使用
pytest —reruns n      # n为重试的次数

```



### 5.fixture

```
# 作用
通常会被用于完成预置处理和重复操作。

# 使用方法
pytest.fixture(scope='function', params=None, autouse=False, ids=None, name=None)

常用参数解释:
-    scope: 被标记方法的作用域;
        "function": 默认值,表示每个测试方法都要执行一次
        "class": 作用于整个类, 表示每个类的所有测试方法只运行一次
        "module": 作用于整个模块, 每个module的所有测试方法只运行一次.

- params: list类型,默认None, 接收参数值,对于param里面的每个值，fixture都会去遍历执行一次.
- autouse: 是否自动运行,默认为false, 为true时此session中的所有测试函数都会调用fixture


作为参数使用：
@pytest.fixture()
def before():
  print("-----> 在每个函数前执行")


def test_1(before):
  print('-----> test_1')
  assert 1
  
  
作为函数使用：
@pytest.fixture()
def before():
    print('\nbefore each test')

@pytest.mark.usefixtures("before")
def test_1():
    print('--->test_1')
    
    
    
作为fixture返回值：

import pytest

@pytest.fixture(params=[1, 2, 3])
def need_data(request): # 传入参数request 系统封装参数
      return request.param # 取列表中单个值，默认的取值方式

class Test_ABC:
    def test_a(self,need_data):
        print("test_a 的值是 %s" % need_data)
        assert need_data != 3 # 断言need_data不等于3

if __name__ == '__main__':
    pytest.main("-s  test_abc.py")

```



### 6.其他

```
#1.跳过测试函数
skipif(condition, reason=None)
参数解释:
    condition: 跳过的条件,必传参数
    reason: 标注原因,必传参数
 
使用方法:
@pytest.mark.skipif(condition, reason='xxx')
    
#2.标记为预期失败函数
方法:
xfail(condition=None, reason=None, raises=None, run=True, strict=False)

常用参数：
   condition：预期失败的条件，必传参数
   reason：失败的原因，必传参数
   
使用方法:
@pytest.mark.xfail(condition, reason="xxx")


#3.函数数据参数化  方便测试函数对测试属性的获取
import pytest

def data():
    return [1,2]

def data1():
    return [(1,2),(3,3),(4,5)]


# @pytest.mark.parametrize("a",[1,2])
# def test_01(a):
#     print("<<<<<<<<test01>>>>>>>>>")
#     print("a=",a)
#     assert a==2

# def test_02():
#     print("<<<<<<<<test02>>>>>>>>>")
#     for a in [1,2]:
#       assert a==2

@pytest.mark.parametrize("a,b",data1())
def test_02(b,a):
    print("<<<<<<<<test02>>>>>>>>>")
    print("a=",a)
    print("b=",b)
    assert a==b


if __name__ == '__main__':
    pytest.main(["-s","test_09.py"])

```

